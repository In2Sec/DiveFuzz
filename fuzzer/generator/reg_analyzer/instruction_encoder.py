"""
RISC-V Instruction Encoder: 
Encoding RISC-V assembly instructions into machine code using the instr_dict.json generated by riscv-opcodes
"""

import json
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

try:
    from .register_mapping import RegisterMapping
except ImportError:
    from register_mapping import RegisterMapping


class InstructionEncoder:
    """RISC-V instruction encoder"""

    def __init__(self, instr_dict_path: Optional[str] = None, arg_lut_path: Optional[str] = None):
        """
        Initialize the encoder

        Args:
            instr_dict_path: instr_dict.json file path
            arg_lut_path: arg_lut.csv file path
        """
        if instr_dict_path is None:
            # Default path
            base_dir = Path(__file__).parent / "riscv-opcodes"
            instr_dict_path = base_dir / "instr_dict.json"

        if arg_lut_path is None:
            base_dir = Path(__file__).parent / "riscv-opcodes"
            arg_lut_path = base_dir / "arg_lut.csv"

        # Load instruction dictionary
        with open(instr_dict_path, 'r') as f:
            self.instr_dict: Dict = json.load(f)

        # Load field position mapping
        self.arg_lut: Dict[str, Tuple[int, int]] = {}
        with open(arg_lut_path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                parts = [p.strip().strip('"') for p in line.split(',')]
                if len(parts) >= 3:
                    field_name = parts[0]
                    msb = int(parts[1])
                    lsb = int(parts[2])
                    self.arg_lut[field_name] = (msb, lsb)

        # Initialize the register mapping
        self.reg_mapper = RegisterMapping()

        # Collect all supported extensions
        self.supported_extensions = self._collect_supported_extensions()

        # Collect all supported instructions
        self.supported_instructions = set(self.instr_dict.keys())

    def _collect_supported_extensions(self) -> set:
        """
        Collect all supported extensions

        Returns:
            A collection of supported extension names
        """
        extensions = set()
        for instr_info in self.instr_dict.values():
            for ext in instr_info.get('extension', []):
                extensions.add(ext.lower())
        return extensions

    def is_instruction_supported(self, opcode: str) -> bool:
        """
        Check whether the instruction is supported

        Args:
            opcode: instruction operation code

        Returns:
            True if supported, False otherwise
        """
        opcode_normalized = opcode.replace('.', '_').lower()
        return opcode_normalized in self.supported_instructions

    def get_instruction_extensions(self, opcode: str) -> Optional[List[str]]:
        """
        Get the extension to which the instruction belongs

        Args:
            opcode: instruction operation code

        Returns:
            Expand the list and return None if the instruction does not exist
        """
        opcode_normalized = opcode.replace('.', '_').lower()
        if opcode_normalized in self.instr_dict:
            return self.instr_dict[opcode_normalized].get('extension', [])
        return None

    def parse_instruction(self, asm_line: str) -> Tuple[str, List[str]]:
        """
        Parse assembly instruction strings (supporting standard RISC-V assembly syntax)

        Args:
            asm_line: Assembly instructions such as "add x1, x2, x3" or "lw x1, 100(x2)"

        Returns:
            (opcode, operands) tuple

        Examples:
            >>> parse_instruction("add x1, x2, x3")
            ('add', ['x1', 'x2', 'x3'])

            >>> parse_instruction("lw x1, 100(x2)")
            ('lw', ['x1', 'x2', '100'])

            >>> parse_instruction("sw x3, -4(x4)")
            ('sw', ['x4', 'x3', '-4'])
        """

        asm_line = asm_line.split('#')[0].strip()
        asm_line = asm_line.split(';')[0].strip()

        if not asm_line:
            raise ValueError("Empty instruction")

        # Check if it is the loading/storage instruction format: opcode rd, imm(rs1) or opcode rs2, imm(rs1) 
        # # Matching mode: Instruction name register, immediate number (register)
        load_store_pattern = r'^\s*(\w+(?:\.\w+)?)\s+(\w+)\s*,\s*(-?\d+(?:x[\da-fA-F]+)?)\s*\(\s*(\w+)\s*\)\s*$'
        match = re.match(load_store_pattern, asm_line)

        if match:
            opcode = match.group(1).lower()
            reg1 = match.group(2)
            imm = match.group(3)
            reg2 = match.group(4)

            load_opcodes = ['lb', 'lh', 'lw', 'ld', 'lbu', 'lhu', 'lwu', 'ldu',
                           'flw', 'fld', 'flq', 'flh'] 
            store_opcodes = ['sb', 'sh', 'sw', 'sd',
                            'fsw', 'fsd', 'fsq', 'fsh']

            if any(opcode.startswith(lo) for lo in load_opcodes):
                # lw rd, imm(rs1) → ['rd', 'rs1', 'imm']
                operands = [reg1, reg2, imm]
            elif any(opcode.startswith(so) for so in store_opcodes):
                # sw rs2, imm(rs1) → ['rs1', 'rs2', 'imm']
                operands = [reg2, reg1, imm]
            else:
                operands = [reg1, reg2, imm]

            return opcode, operands

        parts = re.split(r'[,\s]+', asm_line)
        parts = [p.strip() for p in parts if p.strip()]

        if not parts:
            raise ValueError("Invalid instruction format")

        opcode = parts[0].lower()
        operands = parts[1:]

        return opcode, operands

    def _parse_immediate(self, imm_str: str) -> int:
        """
        Parse immediate numbers

        Args:
            imm_str: Immediate number strings, supporting decimal, hexadecimal (0x), and binary (0b)

        Returns:
            Immediate value
        """
        imm_str = imm_str.strip()

        # Handle hexadecimal
        if imm_str.startswith('0x') or imm_str.startswith('0X'):
            return int(imm_str, 16)

        # Handle binary
        if imm_str.startswith('0b') or imm_str.startswith('0B'):
            return int(imm_str, 2)

        # Decimal (including negative numbers)
        return int(imm_str, 10)

    def _encode_register(self, reg_str: str, field_name: str) -> int:
        """
        Encoding register

        Args:
            reg_str: Register names, such as "x1", "t0", "f0"
            field_name: Field name, used to determine whether it is an integer or a floating-point register

        Returns:
            Register number (0-31)
        """
        reg_str = reg_str.strip()

        # Check whether it is a floating-point register field
        is_float_field = field_name.startswith('f') or 'f' in field_name.lower()

        # If the operand starts with 'f', it is also treated as a floating-point register
        if reg_str.startswith('f'):
            is_float_field = True

        # Use the correct method name
        if is_float_field:
            result = self.reg_mapper.fpr_name_to_num(reg_str)
        else:
            result = self.reg_mapper.xpr_name_to_num(reg_str)

        if result is None:
            raise ValueError(f"Invalid register '{reg_str}' for field '{field_name}'")

        return result

    def _encode_immediate_field(self, imm_value: int, field_name: str, encoding: str) -> int:
        """
        Encode immediate digit segments (process segmented immediate digits)

        Args:
            imm_value: Immediate value
            field_name: field name
            encoding: Instruction encoding string

        Returns:
            The field value after the code
        """
        if field_name not in self.arg_lut:
            raise ValueError(f"Unknown field: {field_name}")

        msb, lsb = self.arg_lut[field_name]
        field_width = msb - lsb + 1

        # Handle segmented immediate numbers (such as bimm12hi/bimm12lo, jimm20, etc.)
        if 'bimm12hi' == field_name:
            # B-type: imm[12|10:5]
            # bit 12 -> bit 31, bits 10:5 -> bits 30:25
            value = ((imm_value >> 12) & 0x1) << 6  # bit 12
            value |= ((imm_value >> 5) & 0x3F)      # bits 10:5
            return value & ((1 << field_width) - 1)

        elif 'bimm12lo' == field_name:
            # B-type: imm[4:1|11]
            # bits 4:1 -> bits 11:8, bit 11 -> bit 7
            value = ((imm_value >> 1) & 0xF) << 1   # bits 4:1
            value |= ((imm_value >> 11) & 0x1)      # bit 11
            return value & ((1 << field_width) - 1)

        elif 'jimm20' == field_name:
            # J-type: imm[20|10:1|11|19:12]
            # bit 20 -> bit 31
            # bits 10:1 -> bits 30:21
            # bit 11 -> bit 20
            # bits 19:12 -> bits 19:12
            value = ((imm_value >> 20) & 0x1) << 19  # bit 20
            value |= ((imm_value >> 1) & 0x3FF) << 9 # bits 10:1
            value |= ((imm_value >> 11) & 0x1) << 8  # bit 11
            value |= ((imm_value >> 12) & 0xFF)      # bits 19:12
            return value & ((1 << field_width) - 1)

        elif 'imm12hi' == field_name:
            # S-type: imm[11:5]
            value = (imm_value >> 5) & 0x7F
            return value & ((1 << field_width) - 1)

        elif 'imm12lo' == field_name:
            # S-type: imm[4:0]
            value = imm_value & 0x1F
            return value & ((1 << field_width) - 1)

        elif 'imm20' == field_name:
            value = imm_value & 0xFFFFF
            return value & ((1 << field_width) - 1)

        elif 'imm12' == field_name or 'csr' == field_name:
            # I-type: imm[11:0]
            if imm_value < 0:
                imm_value = (1 << 12) + imm_value
            return imm_value & ((1 << field_width) - 1)

        elif 'shamtw' == field_name or 'shamtd' == field_name:
            # Shift amount
            return imm_value & ((1 << field_width) - 1)

        else:
            if imm_value < 0:
                imm_value = (1 << field_width) + imm_value
            return imm_value & ((1 << field_width) - 1)

    def encode(self, asm_line: str) -> int:
        """
        Encode assembly instructions into 32-bit machine code

        Args:
            asm_line: Assembly instruction string

        Returns:
            32 Bit Machine Code (int

        Raises:
            ValueError: Instructions with incorrect formats or unsupported instructions

        Examples:
            >>> encoder = InstructionEncoder()
            >>> hex(encoder.encode("add x1, x2, x3"))
            '0x003100b3'

            >>> hex(encoder.encode("addi t0, t1, 100"))
            '0x6430293'
        """
        # Parsing instruction
        opcode, operands = self.parse_instruction(asm_line)

        # Normalized instruction name (replace '.' with '_')
        opcode_normalized = opcode.replace('.', '_')

        # Search instruction definition
        if opcode_normalized not in self.instr_dict:
            # Provide more helpful error messages
            error_msg = f"Unsupported instruction: '{opcode}'\n"
            error_msg += "\nPossible reasons:\n"
            error_msg += "1. The instruction is from an unsupported extension (e.g., P extension, B extension legacy)\n"
            error_msg += "2. The instruction name may have a typo\n"
            error_msg += "3. The instruction may require a specific RISC-V variant (RV32/RV64)\n"
            error_msg += f"\nSupported extensions ({len(self.supported_extensions)}): "
            error_msg += ", ".join(sorted(list(self.supported_extensions))[:10]) + "...\n"
            error_msg += f"Total supported instructions: {len(self.supported_instructions)}\n"
            error_msg += "\nFor unsupported instructions, consider:\n"
            error_msg += "- Using the fallback compiler (riscv-gnu-toolchain)\n"
            error_msg += "- Adding the instruction encoding manually\n"
            raise ValueError(error_msg)

        instr_info = self.instr_dict[opcode_normalized]
        encoding = instr_info['encoding']
        variable_fields = instr_info['variable_fields']
        match = int(instr_info['match'], 16)

        # Immediate Number Splitting for Handling S-type and B-type Instructions 
        # # These instructions use a single immediate number in assembly, but need to be split into hi/lo parts during coding
        if len(operands) != len(variable_fields):
            # Check whether it is an S-type instruction (imm12hi, rs1, rs2, imm12lo)
            if (len(variable_fields) == 4 and len(operands) == 3 and
                variable_fields[0] == 'imm12hi' and variable_fields[3] == 'imm12lo'):
                # S-type: 将 [rs1, rs2, imm] 展开为 [imm_hi, rs1, rs2, imm_lo]
                rs1, rs2, imm = operands
                operands = [imm, rs1, rs2, imm]  # imm will be correctly split in the future
            # Check whether it is a B-type instruction (bimm12hi, rs1, rs2, bimm12lo)
            elif (len(variable_fields) == 4 and len(operands) == 3 and
                  variable_fields[0] == 'bimm12hi' and variable_fields[3] == 'bimm12lo'):
                # B-type: Expand [rs1, rs2, imm] to [imm_hi, rs1, rs2, imm_lo]
                rs1, rs2, imm = operands
                operands = [imm, rs1, rs2, imm]  # imm will be correctly split later
            else:
                raise ValueError(
                    f"Instruction {opcode} expects {len(variable_fields)} operands, "
                    f"but got {len(operands)}"
                )

        # Starting from the match value (including fixed bits)
        machine_code = match

        # Encode each operand
        for operand_str, field_name in zip(operands, variable_fields):
            operand_str = operand_str.strip()

            # Determine the operand type and encode it
            if field_name in ['rd', 'rs1', 'rs2', 'rs3', 'vd', 'vs1', 'vs2', 'vs3']:
                # Register operand
                field_value = self._encode_register(operand_str, field_name)

            elif field_name.startswith('rd') or field_name.startswith('rs') or \
                 field_name.startswith('c_rs') or 'n0' in field_name:
                # Special register fields (such as rd_n0, rs1_n0, etc.)
                field_value = self._encode_register(operand_str, field_name)

            elif 'imm' in field_name or field_name in ['csr', 'shamt', 'shamtw', 'shamtd',
                                                        'zimm', 'simm', 'rm', 'aqrl']:
                # Immediate numbers or special fields
                imm_value = self._parse_immediate(operand_str)
                field_value = self._encode_immediate_field(imm_value, field_name, encoding)

            else:
                # For other fields, try to parse them as numbers
                field_value = self._parse_immediate(operand_str)
                if field_name in self.arg_lut:
                    msb, lsb = self.arg_lut[field_name]
                    field_width = msb - lsb + 1
                    field_value = field_value & ((1 << field_width) - 1)

            # Encode the field values into the machine code
            if field_name in self.arg_lut:
                msb, lsb = self.arg_lut[field_name]
                # Clear the original bits of this field
                mask = ((1 << (msb - lsb + 1)) - 1) << lsb
                machine_code &= ~mask
                # Set a new value
                machine_code |= (field_value << lsb)

        return machine_code

    def encode_to_bytes(self, asm_line: str, little_endian: bool = True) -> bytes:
        """
        Encode assembly instructions as byte sequences

        Args:
            asm_line: Assembly instruction string 
            little_endian: Whether to use little-endian order (default True, RISC-V standard)

        Returns:
            4-byte machine code
        """
        machine_code = self.encode(asm_line)
        byteorder = 'little' if little_endian else 'big'
        return machine_code.to_bytes(4, byteorder=byteorder)

    def encode_to_hex(self, asm_line: str) -> str:
        """
        Encode the assembly instruction as a hexadecimal string

        Args:
            asm_line: Assembly instruction string

        Returns:
            Hexadecimal string (such as "0x003100b3")
        """
        machine_code = self.encode(asm_line)
        return f"0x{machine_code:08x}"

    def encode_multiple(self, asm_lines: List[str]) -> List[int]:
        """
        Batch encode multiple instructions

        Args:
            asm_lines: List of assembly instructions

        Returns:
            Machine code list
        """
        return [self.encode(line) for line in asm_lines if line.strip()]
