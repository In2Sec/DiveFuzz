# Copyright (c) 2024-2025 Institute of Information Engineering, Chinese Academy of Sciences
#
# DiveFuzz is licensed under Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#          http://license.coscl.org.cn/MulanPSL2
#
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
# EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
# MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
#
# See the Mulan PSL v2 for more details.

"""
RISC-V Instruction Encoder:
Encoding RISC-V assembly instructions into machine code using the instr_dict.json generated by riscv-opcodes

Supports special instruction preprocessing:
- fence: Parses "iorw" format for pred/succ fields
- amo: Parses .aq/.rl/.aqrl suffixes for acquire/release ordering
- float: Supports dynamic rm field from frm CSR or explicit rounding mode
- vector: Handles vm field for mask operations
"""

import json
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, Protocol, runtime_checkable

try:
    from .register_mapping import RegisterMapping
except ImportError:
    from register_mapping import RegisterMapping


# ============================================================================
# Context Provider Protocol
# ============================================================================

@runtime_checkable
class ContextProvider(Protocol):
    """
    Protocol for providing dynamic context information to the encoder.

    Implementations can provide CSR values, register states, etc.
    This enables the encoder to use runtime values when encoding instructions.

    Example implementation with SpikeSession:
        class SpikeContextProvider:
            def __init__(self, session: SpikeSession):
                self.session = session

            def get_csr(self, addr: int) -> int:
                return self.session.get_csr(addr)
    """

    def get_csr(self, addr: int) -> int:
        """Get CSR value by address"""
        ...


class DefaultContextProvider:
    """
    Default context provider with static default values.

    Used when no external context is provided.
    """

    # CSR addresses
    CSR_FRM = 0x002      # Floating-point rounding mode
    CSR_FCSR = 0x003     # Floating-point control and status
    CSR_VSTART = 0x008   # Vector start position
    CSR_VXSAT = 0x009    # Fixed-point saturate flag
    CSR_VXRM = 0x00A     # Fixed-point rounding mode
    CSR_VCSR = 0x00F     # Vector control and status
    CSR_VL = 0xC20       # Vector length
    CSR_VTYPE = 0xC21    # Vector data type
    CSR_VLENB = 0xC22    # Vector register length in bytes

    def __init__(self, default_frm: int = 7):
        """
        Initialize with default values.

        Args:
            default_frm: Default floating-point rounding mode (7 = dynamic)
        """
        self._defaults = {
            self.CSR_FRM: default_frm,
            self.CSR_FCSR: default_frm,  # frm is bits [7:5] of fcsr
        }

    def get_csr(self, addr: int) -> int:
        """Get CSR value, returns default or 0"""
        return self._defaults.get(addr, 0)


class InstructionEncoder:
    """
    RISC-V instruction encoder with special instruction preprocessing.

    Supports:
    - Standard RISC-V instructions (R/I/S/B/U/J types)
    - fence instructions with "iorw" format parsing
    - AMO instructions with .aq/.rl/.aqrl suffix parsing
    - Floating-point instructions with dynamic rm field
    - Vector instructions with vm field handling
    """

    # Rounding mode name to value mapping
    ROUNDING_MODES = {
        'rne': 0,  # Round to Nearest, ties to Even
        'rtz': 1,  # Round towards Zero
        'rdn': 2,  # Round Down (towards -inf)
        'rup': 3,  # Round Up (towards +inf)
        'rmm': 4,  # Round to Nearest, ties to Max Magnitude
        'dyn': 7,  # Dynamic (use frm CSR)
    }

    # Fence predecessor/successor bit mapping
    FENCE_BITS = {
        'i': 8,  # Input (device input)
        'o': 4,  # Output (device output)
        'r': 2,  # Read (memory reads)
        'w': 1,  # Write (memory writes)
    }

    def __init__(
        self,
        instr_dict_path: Optional[str] = None,
        arg_lut_path: Optional[str] = None,
        context_provider: Optional[ContextProvider] = None
    ):
        """
        Initialize the encoder

        Args:
            instr_dict_path: instr_dict.json file path
            arg_lut_path: arg_lut.csv file path
            context_provider: Optional context provider for dynamic values (CSRs, etc.)
        """
        if instr_dict_path is None:
            # Default path
            base_dir = Path(__file__).parent / "riscv-opcodes"
            instr_dict_path = base_dir / "instr_dict.json"

        if arg_lut_path is None:
            base_dir = Path(__file__).parent / "riscv-opcodes"
            arg_lut_path = base_dir / "arg_lut.csv"

        # Load instruction dictionary
        with open(instr_dict_path, 'r') as f:
            self.instr_dict: Dict = json.load(f)

        # Load field position mapping
        self.arg_lut: Dict[str, Tuple[int, int]] = {}
        with open(arg_lut_path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                parts = [p.strip().strip('"') for p in line.split(',')]
                if len(parts) >= 3:
                    field_name = parts[0]
                    msb = int(parts[1])
                    lsb = int(parts[2])
                    self.arg_lut[field_name] = (msb, lsb)

        # Initialize the register mapping
        self.reg_mapper = RegisterMapping()

        # Context provider for dynamic values
        self.context_provider = context_provider or DefaultContextProvider()

        # Collect all supported extensions
        self.supported_extensions = self._collect_supported_extensions()

        # Collect all supported instructions
        self.supported_instructions = set(self.instr_dict.keys())

        # Build instruction category caches for fast lookup
        self._build_instruction_caches()

    def set_context_provider(self, provider: ContextProvider) -> None:
        """
        Set or update the context provider.

        Args:
            provider: New context provider instance
        """
        self.context_provider = provider

    def _build_instruction_caches(self) -> None:
        """Build caches for special instruction categories"""
        # AMO instructions (have aq/rl fields)
        self._amo_instructions = set()
        # Floating-point instructions with rm field
        self._fp_rm_instructions = set()
        # Vector instructions with vm field
        self._vector_vm_instructions = set()

        for name, info in self.instr_dict.items():
            fields = info.get('variable_fields', [])
            if 'aq' in fields or 'rl' in fields:
                self._amo_instructions.add(name)
            if 'rm' in fields:
                self._fp_rm_instructions.add(name)
            if 'vm' in fields:
                self._vector_vm_instructions.add(name)

    def _collect_supported_extensions(self) -> set:
        """
        Collect all supported extensions

        Returns:
            A collection of supported extension names
        """
        extensions = set()
        for instr_info in self.instr_dict.values():
            for ext in instr_info.get('extension', []):
                extensions.add(ext.lower())
        return extensions

    # ========================================================================
    # Special Instruction Preprocessing Methods
    # ========================================================================

    def _parse_fence_operand(self, operand: str) -> int:
        """
        Parse fence predecessor/successor operand (e.g., "iorw", "rw", "w")

        Args:
            operand: Fence operand string like "iorw", "rw", "w"

        Returns:
            4-bit value representing the fence flags

        Examples:
            >>> _parse_fence_operand("iorw")
            15  # 0b1111
            >>> _parse_fence_operand("rw")
            3   # 0b0011
            >>> _parse_fence_operand("w")
            1   # 0b0001
        """
        operand = operand.strip().lower()
        value = 0
        for char in operand:
            if char in self.FENCE_BITS:
                value |= self.FENCE_BITS[char]
            elif char not in ' ,':
                raise ValueError(f"Invalid fence operand character: '{char}'")
        return value

    def _preprocess_fence(
        self,
        opcode: str,
        operands: List[str],
        variable_fields: List[str]
    ) -> Tuple[str, List[str]]:
        """
        Preprocess fence instruction to expand operands.

        Transforms:
            fence           -> fence fm=0, pred=15, succ=15, rs1=0, rd=0
            fence iorw,iorw -> fence fm=0, pred=15, succ=15, rs1=0, rd=0
            fence rw, rw    -> fence fm=0, pred=3, succ=3, rs1=0, rd=0

        Args:
            opcode: Instruction opcode ("fence")
            operands: Parsed operands (may be empty or contain pred,succ)
            variable_fields: Expected fields from instr_dict

        Returns:
            (opcode, expanded_operands) tuple
        """
        # fence has fields: ['fm', 'pred', 'succ', 'rs1', 'rd']
        if opcode != 'fence':
            return opcode, operands

        # Default values
        fm = 0
        pred = 15  # iorw = 0b1111
        succ = 15  # iorw = 0b1111

        if len(operands) == 0:
            # fence without operands: use defaults (iorw, iorw)
            pass
        elif len(operands) == 2:
            # fence pred, succ
            pred = self._parse_fence_operand(operands[0])
            succ = self._parse_fence_operand(operands[1])
        elif len(operands) == 1:
            # Some assemblers might accept single operand
            pred = self._parse_fence_operand(operands[0])
            succ = pred
        else:
            raise ValueError(f"fence instruction expects 0 or 2 operands, got {len(operands)}")

        # Build operands matching variable_fields order: ['fm', 'pred', 'succ', 'rs1', 'rd']
        # Note: rs1 and rd must be 'x0' (register name), not '0' (number)
        expanded = [str(fm), str(pred), str(succ), 'x0', 'x0']
        return opcode, expanded

    def _preprocess_amo(
        self,
        opcode: str,
        operands: List[str],
        variable_fields: List[str]
    ) -> Tuple[str, List[str]]:
        """
        Preprocess AMO instruction to handle .aq/.rl suffixes and register operands.

        Note: parse_instruction already handles the (rs1) parentheses and returns
        operands in the order [rd, rs1, rs2] for AMO or [rd, rs1] for LR.

        The variable_fields order is typically:
        - AMO: ['rd', 'rs1', 'rs2', 'aq', 'rl']
        - LR:  ['rd', 'rs1', 'aq', 'rl']
        - SC:  ['rd', 'rs1', 'rs2', 'aq', 'rl']

        This function adds default aq=0, rl=0 to complete the operands.
        The actual aq/rl values from .aq/.rl suffixes are handled in encode().

        Args:
            opcode: Instruction opcode (suffix already stripped by encode())
            operands: Parsed operands [rd, rs1, rs2] or [rd, rs1]
            variable_fields: Expected fields from instr_dict

        Returns:
            (opcode, expanded_operands) tuple with aq/rl fields added
        """
        opcode_normalized = opcode.replace('.', '_')

        # Check if this is an AMO/LR/SC instruction
        if opcode_normalized not in self._amo_instructions:
            return opcode, operands

        # Build operands matching expected field order
        # Add aq=0, rl=0 as defaults (will be overwritten by encode() if suffix present)
        expanded = []
        operand_idx = 0

        for field in variable_fields:
            if field == 'aq':
                expanded.append('0')  # Default, may be overwritten
            elif field == 'rl':
                expanded.append('0')  # Default, may be overwritten
            elif operand_idx < len(operands):
                expanded.append(operands[operand_idx])
                operand_idx += 1
            else:
                expanded.append('x0')  # Default register

        return opcode, expanded

    def _get_dynamic_rm(self) -> int:
        """
        Get dynamic rounding mode from frm CSR.

        Returns:
            Rounding mode value (0-7)
        """
        frm = self.context_provider.get_csr(DefaultContextProvider.CSR_FRM)
        return frm & 0x7

    # Instructions where GNU as uses rm=0 and doesn't support explicit dyn syntax
    # These are int-to-float and float-to-float conversions
    _FP_RM0_INSTRUCTIONS = {
        # int-to-float: GNU as defaults to rm=0, doesn't accept ", dyn"
        'fcvt_s_w', 'fcvt_s_wu', 'fcvt_s_l', 'fcvt_s_lu',
        'fcvt_d_w', 'fcvt_d_wu', 'fcvt_d_l', 'fcvt_d_lu',
        # float-to-float: GNU as defaults to rm=0, doesn't accept ", dyn"
        'fcvt_s_d', 'fcvt_d_s',
        'fcvt_s_h', 'fcvt_h_s', 'fcvt_d_h', 'fcvt_h_d',
        'fcvt_s_q', 'fcvt_q_s', 'fcvt_d_q', 'fcvt_q_d',
    }

    def _preprocess_fp_rm(
        self,
        opcode: str,
        operands: List[str],
        variable_fields: List[str]
    ) -> Tuple[str, List[str]]:
        """
        Preprocess floating-point instruction to handle rm field.

        If rm is not specified in operands:
        - For instructions in _FP_RM0_INSTRUCTIONS: uses rm=0 (rne) to match GNU as
        - For other instructions: uses rm=7 (dyn) which reads from frm CSR at runtime

        If rm is specified as rne/rtz/rdn/rup/rmm/dyn:
        - Converts to numeric value

        Args:
            opcode: Instruction opcode
            operands: Parsed operands
            variable_fields: Expected fields from instr_dict

        Returns:
            (opcode, expanded_operands) tuple
        """
        opcode_normalized = opcode.replace('.', '_')

        if opcode_normalized not in self._fp_rm_instructions:
            return opcode, operands

        if 'rm' not in variable_fields:
            return opcode, operands

        # Find rm field position
        rm_index = variable_fields.index('rm')
        num_register_fields = sum(1 for f in variable_fields if f in ('rd', 'rs1', 'rs2', 'rs3'))

        # Check if rm is provided in operands
        if len(operands) > num_register_fields:
            # rm might be explicitly specified
            last_operand = operands[-1].strip().lower()
            if last_operand in self.ROUNDING_MODES:
                # Convert rounding mode name to value
                rm_value = self.ROUNDING_MODES[last_operand]
                operands = list(operands[:-1]) + [str(rm_value)]
            # else: assume it's already a numeric value

        # If operands don't include rm, add default
        if len(operands) < len(variable_fields):
            # Determine default rm value based on instruction type
            # For int-to-float and float-to-float conversions, GNU as uses rm=0
            # and doesn't support explicit ", dyn" syntax
            if opcode_normalized in self._FP_RM0_INSTRUCTIONS:
                rm_value = 0  # rne - matches GNU as default
            else:
                rm_value = 7  # dyn - reads from frm CSR at runtime

            # Insert rm at the correct position
            expanded = list(operands)
            while len(expanded) < rm_index:
                expanded.append('0')
            expanded.insert(rm_index, str(rm_value))

            # Ensure we have all fields
            while len(expanded) < len(variable_fields):
                expanded.append('0')

            return opcode, expanded

        return opcode, operands

    def _preprocess_vector_vm(
        self,
        opcode: str,
        operands: List[str],
        variable_fields: List[str]
    ) -> Tuple[str, List[str]]:
        """
        Preprocess vector instruction to handle vm (mask) field.

        vm=1: No masking (all elements active)
        vm=0: Use v0 as mask register

        Syntax variants:
        - vadd.vv vd, vs1, vs2         -> vm=1 (unmasked)
        - vadd.vv vd, vs1, vs2, v0.t   -> vm=0 (masked with v0)

        Args:
            opcode: Instruction opcode
            operands: Parsed operands
            variable_fields: Expected fields from instr_dict

        Returns:
            (opcode, expanded_operands) tuple
        """
        opcode_normalized = opcode.replace('.', '_')

        if opcode_normalized not in self._vector_vm_instructions:
            return opcode, operands

        if 'vm' not in variable_fields:
            return opcode, operands

        # Check if masking is specified
        vm = 1  # Default: unmasked

        if operands and operands[-1].strip().lower() == 'v0.t':
            # Masked operation
            vm = 0
            operands = list(operands[:-1])

        # Find vm field position and insert
        vm_index = variable_fields.index('vm')

        # Build expanded operands
        expanded = []
        operand_idx = 0

        for i, field in enumerate(variable_fields):
            if field == 'vm':
                expanded.append(str(vm))
            else:
                if operand_idx < len(operands):
                    expanded.append(operands[operand_idx])
                    operand_idx += 1
                else:
                    expanded.append('0')

        return opcode, expanded

    def _preprocess_instruction(
        self,
        opcode: str,
        operands: List[str],
        variable_fields: List[str]
    ) -> Tuple[str, List[str]]:
        """
        Main preprocessing dispatcher for special instructions.

        Applies appropriate preprocessing based on instruction type.

        Args:
            opcode: Instruction opcode
            operands: Parsed operands
            variable_fields: Expected fields from instr_dict

        Returns:
            (processed_opcode, processed_operands) tuple
        """
        # fence instruction
        if opcode == 'fence':
            return self._preprocess_fence(opcode, operands, variable_fields)

        # AMO instructions (check suffix first)
        if (opcode.startswith('amo') or opcode.startswith('lr.') or
            opcode.startswith('sc.') or '.aq' in opcode or '.rl' in opcode):
            return self._preprocess_amo(opcode, operands, variable_fields)

        # Floating-point instructions with rm
        opcode_normalized = opcode.replace('.', '_')
        if opcode_normalized in self._fp_rm_instructions:
            return self._preprocess_fp_rm(opcode, operands, variable_fields)

        # Vector instructions with vm
        if opcode_normalized in self._vector_vm_instructions:
            return self._preprocess_vector_vm(opcode, operands, variable_fields)

        return opcode, operands

    # ========================================================================
    # Public API Methods
    # ========================================================================

    def is_instruction_supported(self, opcode: str) -> bool:
        """
        Check whether the instruction is supported

        Args:
            opcode: instruction operation code

        Returns:
            True if supported, False otherwise
        """
        opcode_normalized = opcode.replace('.', '_').lower()
        return opcode_normalized in self.supported_instructions

    def get_instruction_extensions(self, opcode: str) -> Optional[List[str]]:
        """
        Get the extension to which the instruction belongs

        Args:
            opcode: instruction operation code

        Returns:
            Expand the list and return None if the instruction does not exist
        """
        opcode_normalized = opcode.replace('.', '_').lower()
        if opcode_normalized in self.instr_dict:
            return self.instr_dict[opcode_normalized].get('extension', [])
        return None

    def parse_instruction(self, asm_line: str) -> Tuple[str, List[str]]:
        """
        Parse assembly instruction strings (supporting standard RISC-V assembly syntax)

        Args:
            asm_line: Assembly instructions such as "add x1, x2, x3" or "lw x1, 100(x2)"

        Returns:
            (opcode, operands) tuple

        Examples:
            >>> parse_instruction("add x1, x2, x3")
            ('add', ['x1', 'x2', 'x3'])

            >>> parse_instruction("lw x1, 100(x2)")
            ('lw', ['x1', 'x2', '100'])

            >>> parse_instruction("sw x3, -4(x4)")
            ('sw', ['x4', 'x3', '-4'])
        """

        asm_line = asm_line.split('#')[0].strip()
        asm_line = asm_line.split(';')[0].strip()

        if not asm_line:
            raise ValueError("Empty instruction")

        # Check if it is the loading/storage instruction format: opcode rd, imm(rs1) or opcode rs2, imm(rs1) 
        # # Matching mode: Instruction name register, immediate number (register)
        load_store_pattern = r'^\s*(\w+(?:\.\w+)?)\s+(\w+)\s*,\s*(-?\d+(?:x[\da-fA-F]+)?)\s*\(\s*(\w+)\s*\)\s*$'
        match = re.match(load_store_pattern, asm_line)

        if match:
            opcode = match.group(1).lower()
            reg1 = match.group(2)
            imm = match.group(3)
            reg2 = match.group(4)

            load_opcodes = ['lb', 'lh', 'lw', 'ld', 'lbu', 'lhu', 'lwu', 'ldu',
                           'flw', 'fld', 'flq', 'flh'] 
            store_opcodes = ['sb', 'sh', 'sw', 'sd',
                            'fsw', 'fsd', 'fsq', 'fsh']

            if any(opcode.startswith(lo) for lo in load_opcodes):
                # lw rd, imm(rs1) → ['rd', 'rs1', 'imm']
                operands = [reg1, reg2, imm]
            elif any(opcode.startswith(so) for so in store_opcodes):
                # sw rs2, imm(rs1) → ['rs1', 'rs2', 'imm']
                operands = [reg2, reg1, imm]
            else:
                operands = [reg1, reg2, imm]

            return opcode, operands

        # Check for AMO instruction format: opcode rd, rs2, (rs1)
        amo_pattern = r'^\s*(\w+(?:\.\w+)*)\s+(\w+)\s*,\s*(\w+)\s*,\s*\(\s*(\w+)\s*\)\s*$'
        amo_match = re.match(amo_pattern, asm_line)
        if amo_match:
            opcode = amo_match.group(1).lower()
            rd = amo_match.group(2)
            rs2 = amo_match.group(3)
            rs1 = amo_match.group(4)
            # AMO field order is typically [rd, rs1, rs2, aq, rl]
            # Return in the order matching variable_fields
            return opcode, [rd, rs1, rs2]

        # Check for LR instruction format: lr.w rd, (rs1)
        lr_pattern = r'^\s*(lr\.\w+(?:\.\w+)*)\s+(\w+)\s*,\s*\(\s*(\w+)\s*\)\s*$'
        lr_match = re.match(lr_pattern, asm_line, re.IGNORECASE)
        if lr_match:
            opcode = lr_match.group(1).lower()
            rd = lr_match.group(2)
            rs1 = lr_match.group(3)
            return opcode, [rd, rs1]

        # Check for SC instruction format: sc.w rd, rs2, (rs1)
        sc_pattern = r'^\s*(sc\.\w+(?:\.\w+)*)\s+(\w+)\s*,\s*(\w+)\s*,\s*\(\s*(\w+)\s*\)\s*$'
        sc_match = re.match(sc_pattern, asm_line, re.IGNORECASE)
        if sc_match:
            opcode = sc_match.group(1).lower()
            rd = sc_match.group(2)
            rs2 = sc_match.group(3)
            rs1 = sc_match.group(4)
            return opcode, [rd, rs1, rs2]

        parts = re.split(r'[,\s]+', asm_line)
        parts = [p.strip() for p in parts if p.strip()]

        if not parts:
            raise ValueError("Invalid instruction format")

        opcode = parts[0].lower()
        operands = parts[1:]

        return opcode, operands

    def _parse_immediate(self, imm_str: str) -> int:
        """
        Parse immediate numbers

        Args:
            imm_str: Immediate number strings, supporting decimal, hexadecimal (0x), and binary (0b)

        Returns:
            Immediate value
        """
        imm_str = imm_str.strip()

        # Handle hexadecimal
        if imm_str.startswith('0x') or imm_str.startswith('0X'):
            return int(imm_str, 16)

        # Handle binary
        if imm_str.startswith('0b') or imm_str.startswith('0B'):
            return int(imm_str, 2)

        # Decimal (including negative numbers)
        return int(imm_str, 10)

    def _encode_register(self, reg_str: str, field_name: str) -> int:
        """
        Encoding register

        Args:
            reg_str: Register names, such as "x1", "t0", "f0"
            field_name: Field name, used to determine whether it is an integer or a floating-point register

        Returns:
            Register number (0-31)
        """
        reg_str = reg_str.strip()

        # Check whether it is a floating-point register field
        # Use field_name hint or detect from register name itself
        is_float_field = field_name.startswith('f') or 'f' in field_name.lower()

        # Use RegisterMapping.is_float_register to correctly identify float registers
        # Note: 'fp' (frame pointer) is an INTEGER register, not a float register!
        if self.reg_mapper.is_float_register(reg_str):
            is_float_field = True

        # Use the correct method name
        if is_float_field:
            result = self.reg_mapper.fpr_name_to_num(reg_str)
        else:
            result = self.reg_mapper.xpr_name_to_num(reg_str)

        if result is None:
            raise ValueError(f"Invalid register '{reg_str}' for field '{field_name}'")

        return result

    def _encode_immediate_field(self, imm_value: int, field_name: str, encoding: str) -> int:
        """
        Encode immediate digit segments (process segmented immediate digits)

        Args:
            imm_value: Immediate value
            field_name: field name
            encoding: Instruction encoding string

        Returns:
            The field value after the code
        """
        if field_name not in self.arg_lut:
            raise ValueError(f"Unknown field: {field_name}")

        msb, lsb = self.arg_lut[field_name]
        field_width = msb - lsb + 1

        # Handle segmented immediate numbers (such as bimm12hi/bimm12lo, jimm20, etc.)
        if 'bimm12hi' == field_name:
            # B-type: imm[12|10:5]
            # bit 12 -> bit 31, bits 10:5 -> bits 30:25
            value = ((imm_value >> 12) & 0x1) << 6  # bit 12
            value |= ((imm_value >> 5) & 0x3F)      # bits 10:5
            return value & ((1 << field_width) - 1)

        elif 'bimm12lo' == field_name:
            # B-type: imm[4:1|11]
            # bits 4:1 -> bits 11:8, bit 11 -> bit 7
            value = ((imm_value >> 1) & 0xF) << 1   # bits 4:1
            value |= ((imm_value >> 11) & 0x1)      # bit 11
            return value & ((1 << field_width) - 1)

        elif 'jimm20' == field_name:
            # J-type: imm[20|10:1|11|19:12]
            # bit 20 -> bit 31
            # bits 10:1 -> bits 30:21
            # bit 11 -> bit 20
            # bits 19:12 -> bits 19:12
            value = ((imm_value >> 20) & 0x1) << 19  # bit 20
            value |= ((imm_value >> 1) & 0x3FF) << 9 # bits 10:1
            value |= ((imm_value >> 11) & 0x1) << 8  # bit 11
            value |= ((imm_value >> 12) & 0xFF)      # bits 19:12
            return value & ((1 << field_width) - 1)

        elif 'imm12hi' == field_name:
            # S-type: imm[11:5]
            value = (imm_value >> 5) & 0x7F
            return value & ((1 << field_width) - 1)

        elif 'imm12lo' == field_name:
            # S-type: imm[4:0]
            value = imm_value & 0x1F
            return value & ((1 << field_width) - 1)

        elif 'imm20' == field_name:
            value = imm_value & 0xFFFFF
            return value & ((1 << field_width) - 1)

        elif 'imm12' == field_name or 'csr' == field_name:
            # I-type: imm[11:0]
            if imm_value < 0:
                imm_value = (1 << 12) + imm_value
            return imm_value & ((1 << field_width) - 1)

        elif 'shamtw' == field_name or 'shamtd' == field_name:
            # Shift amount
            return imm_value & ((1 << field_width) - 1)

        else:
            if imm_value < 0:
                imm_value = (1 << field_width) + imm_value
            return imm_value & ((1 << field_width) - 1)

    def encode(self, asm_line: str) -> int:
        """
        Encode assembly instructions into 32-bit machine code

        Supports special instruction preprocessing:
        - fence: Parses "iorw" format, expands to fm/pred/succ/rs1/rd
        - amo: Parses .aq/.rl/.aqrl suffixes
        - float: Handles rm field (dynamic from frm CSR or explicit)
        - vector: Handles vm field for mask operations

        Args:
            asm_line: Assembly instruction string

        Returns:
            32-bit machine code as integer

        Raises:
            ValueError: If instruction format is incorrect or unsupported

        Examples:
            >>> encoder = InstructionEncoder()
            >>> hex(encoder.encode("add x1, x2, x3"))
            '0x003100b3'
            >>> hex(encoder.encode("fence"))
            '0x0ff0000f'
            >>> hex(encoder.encode("fence rw, rw"))
            '0x0330000f'
            >>> hex(encoder.encode("amoadd.w.aq x1, x2, (x3)"))
            '0x0421a0af'
        """
        # Step 1: Parse instruction
        opcode, operands = self.parse_instruction(asm_line)

        # Step 2: Handle AMO instruction suffixes BEFORE looking up in dict
        # This is needed because amoadd.w.aq needs to become amoadd_w
        original_opcode = opcode
        aq_suffix = 0
        rl_suffix = 0

        if '.aqrl' in opcode:
            aq_suffix = 1
            rl_suffix = 1
            opcode = opcode.replace('.aqrl', '')
        elif '.aq' in opcode:
            aq_suffix = 1
            opcode = opcode.replace('.aq', '')
        elif '.rl' in opcode:
            rl_suffix = 1
            opcode = opcode.replace('.rl', '')

        # Normalize instruction name (replace '.' with '_')
        opcode_normalized = opcode.replace('.', '_')

        # Step 3: Search instruction definition
        if opcode_normalized not in self.instr_dict:
            # Provide more helpful error messages
            error_msg = f"Unsupported instruction: '{original_opcode}'\n"
            error_msg += "\nPossible reasons:\n"
            error_msg += "1. The instruction is from an unsupported extension (e.g., P extension, B extension legacy)\n"
            error_msg += "2. The instruction name may have a typo\n"
            error_msg += "3. The instruction may require a specific RISC-V variant (RV32/RV64)\n"
            error_msg += f"\nSupported extensions ({len(self.supported_extensions)}): "
            error_msg += ", ".join(sorted(list(self.supported_extensions))[:10]) + "...\n"
            error_msg += f"Total supported instructions: {len(self.supported_instructions)}\n"
            error_msg += "\nFor unsupported instructions, consider:\n"
            error_msg += "- Using the fallback compiler (riscv-gnu-toolchain)\n"
            error_msg += "- Adding the instruction encoding manually\n"
            raise ValueError(error_msg)

        instr_info = self.instr_dict[opcode_normalized]
        encoding = instr_info['encoding']
        variable_fields = instr_info['variable_fields']
        match = int(instr_info['match'], 16)

        # Step 4: Apply special instruction preprocessing
        opcode, operands = self._preprocess_instruction(opcode, operands, variable_fields)

        # Step 5: Handle AMO aq/rl fields if instruction has them
        if opcode_normalized in self._amo_instructions and (aq_suffix or rl_suffix):
            # Rebuild operands with aq/rl values
            expanded = []
            operand_idx = 0
            for field in variable_fields:
                if field == 'aq':
                    expanded.append(str(aq_suffix))
                elif field == 'rl':
                    expanded.append(str(rl_suffix))
                elif operand_idx < len(operands):
                    expanded.append(operands[operand_idx])
                    operand_idx += 1
                else:
                    expanded.append('0')
            operands = expanded

        # Step 6: Handle S-type and B-type immediate splitting
        if len(operands) != len(variable_fields):
            # Check whether it is an S-type instruction (imm12hi, rs1, rs2, imm12lo)
            if (len(variable_fields) == 4 and len(operands) == 3 and
                variable_fields[0] == 'imm12hi' and variable_fields[3] == 'imm12lo'):
                # S-type: [rs1, rs2, imm] -> [imm_hi, rs1, rs2, imm_lo]
                rs1, rs2, imm = operands
                operands = [imm, rs1, rs2, imm]
            # Check whether it is a B-type instruction (bimm12hi, rs1, rs2, bimm12lo)
            elif (len(variable_fields) == 4 and len(operands) == 3 and
                  variable_fields[0] == 'bimm12hi' and variable_fields[3] == 'bimm12lo'):
                # B-type: [rs1, rs2, imm] -> [imm_hi, rs1, rs2, imm_lo]
                rs1, rs2, imm = operands
                operands = [imm, rs1, rs2, imm]
            else:
                raise ValueError(
                    f"Instruction {original_opcode} expects {len(variable_fields)} operands "
                    f"({variable_fields}), but got {len(operands)} ({operands})"
                )

        # Starting from the match value (including fixed bits)
        machine_code = match

        # Encode each operand
        for operand_str, field_name in zip(operands, variable_fields):
            operand_str = operand_str.strip()

            # Determine the operand type and encode it
            if field_name in ['rd', 'rs1', 'rs2', 'rs3', 'vd', 'vs1', 'vs2', 'vs3']:
                # Register operand
                field_value = self._encode_register(operand_str, field_name)

            elif field_name.startswith('rd') or field_name.startswith('rs') or \
                 field_name.startswith('c_rs') or 'n0' in field_name:
                # Special register fields (such as rd_n0, rs1_n0, etc.)
                field_value = self._encode_register(operand_str, field_name)

            elif 'imm' in field_name or field_name in ['csr', 'shamt', 'shamtw', 'shamtd',
                                                        'zimm', 'simm', 'rm', 'aqrl']:
                # Immediate numbers or special fields
                imm_value = self._parse_immediate(operand_str)
                field_value = self._encode_immediate_field(imm_value, field_name, encoding)

            else:
                # For other fields, try to parse them as numbers
                field_value = self._parse_immediate(operand_str)
                if field_name in self.arg_lut:
                    msb, lsb = self.arg_lut[field_name]
                    field_width = msb - lsb + 1
                    field_value = field_value & ((1 << field_width) - 1)

            # Encode the field values into the machine code
            if field_name in self.arg_lut:
                msb, lsb = self.arg_lut[field_name]
                # Clear the original bits of this field
                mask = ((1 << (msb - lsb + 1)) - 1) << lsb
                machine_code &= ~mask
                # Set a new value
                machine_code |= (field_value << lsb)

        return machine_code

    def encode_to_bytes(self, asm_line: str, little_endian: bool = True) -> bytes:
        """
        Encode assembly instructions as byte sequences

        Args:
            asm_line: Assembly instruction string 
            little_endian: Whether to use little-endian order (default True, RISC-V standard)

        Returns:
            4-byte machine code
        """
        machine_code = self.encode(asm_line)
        byteorder = 'little' if little_endian else 'big'
        return machine_code.to_bytes(4, byteorder=byteorder)

    def encode_to_hex(self, asm_line: str) -> str:
        """
        Encode the assembly instruction as a hexadecimal string

        Args:
            asm_line: Assembly instruction string

        Returns:
            Hexadecimal string (such as "0x003100b3")
        """
        machine_code = self.encode(asm_line)
        return f"0x{machine_code:08x}"

    def encode_multiple(self, asm_lines: List[str]) -> List[int]:
        """
        Batch encode multiple instructions

        Args:
            asm_lines: List of assembly instructions

        Returns:
            Machine code list
        """
        return [self.encode(line) for line in asm_lines if line.strip()]
